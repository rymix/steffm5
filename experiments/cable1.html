<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coiled Telephone Wire Physics</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "Segoe UI", system-ui, sans-serif;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      canvas {
        display: block;
      }

      .box {
        position: absolute;
        width: 120px;
        height: 80px;
        background: linear-gradient(145deg, #e8e8e8, #c4c4c4);
        border-radius: 12px;
        cursor: grab;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow:
          0 10px 30px rgba(0, 0, 0, 0.4),
          inset 0 2px 0 rgba(255, 255, 255, 0.5),
          inset 0 -2px 0 rgba(0, 0, 0, 0.1);
        user-select: none;
        transition: box-shadow 0.2s;
      }

      .box:active {
        cursor: grabbing;
        box-shadow:
          0 5px 20px rgba(0, 0, 0, 0.5),
          inset 0 2px 0 rgba(255, 255, 255, 0.5),
          inset 0 -2px 0 rgba(0, 0, 0, 0.1);
      }

      .box-label {
        font-size: 11px;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
      }

      .box-icon {
        font-size: 28px;
      }

      .wire-port {
        position: absolute;
        width: 14px;
        height: 14px;
        background: #2a2a2a;
        border-radius: 50%;
        border: 2px solid #444;
      }

      #box1 .wire-port {
        bottom: -7px;
        left: 50%;
        transform: translateX(-50%);
      }

      #box2 .wire-port {
        top: -7px;
        left: 50%;
        transform: translateX(-50%);
      }

      .controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 15px 25px;
        border-radius: 12px;
        display: flex;
        gap: 20px;
        align-items: center;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .control-group label {
        color: #aaa;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .control-group input[type="range"] {
        width: 120px;
        accent-color: #e94560;
      }

      .info {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="canvas"></canvas>

      <div class="box" id="box1">
        <div class="wire-port"></div>
        <span class="box-label">Unit A</span>
        <span class="box-icon">ðŸ“ž</span>
      </div>

      <div class="box" id="box2">
        <div class="wire-port"></div>
        <span class="box-label">Unit B</span>
        <span class="box-icon">ðŸ”Œ</span>
      </div>
    </div>

    <div class="info">Drag the boxes to stretch the coiled wire</div>

    <div class="controls">
      <div class="control-group">
        <label>Stiffness</label>
        <input
          type="range"
          id="stiffness"
          min="0.01"
          max="0.15"
          step="0.01"
          value="0.06"
        />
      </div>
      <div class="control-group">
        <label>Damping</label>
        <input
          type="range"
          id="damping"
          min="0.9"
          max="0.995"
          step="0.005"
          value="0.97"
        />
      </div>
      <div class="control-group">
        <label>Coil Tightness</label>
        <input
          type="range"
          id="coilTightness"
          min="0.3"
          max="2"
          step="0.1"
          value="1"
        />
      </div>
      <div class="control-group">
        <label>Gravity</label>
        <input
          type="range"
          id="gravity"
          min="0"
          max="0.5"
          step="0.02"
          value="0.15"
        />
      </div>
      <div class="control-group">
        <label>Wire Length</label>
        <input
          type="range"
          id="wireLength"
          min="20"
          max="100"
          step="5"
          value="40"
        />
      </div>
    </div>

    <script>
      // Canvas setup
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Physics parameters
      let stiffness = 0.06;
      let damping = 0.97;
      let gravity = 0.15;
      let coilTightness = 1;

      // Wire configuration
      let numSegments = 40;
      const restLength = 12;

      // Particle class for Verlet integration
      class Particle {
        constructor(x, y, pinned = false) {
          this.x = x;
          this.y = y;
          this.oldX = x;
          this.oldY = y;
          this.pinned = pinned;
        }

        update() {
          if (this.pinned) return;

          const vx = (this.x - this.oldX) * damping;
          const vy = (this.y - this.oldY) * damping;

          this.oldX = this.x;
          this.oldY = this.y;

          this.x += vx;
          this.y += vy + gravity;
        }
      }

      // Initialize particles
      let particles = [];

      function initParticles() {
        particles = [];
        const box1 = document.getElementById("box1");
        const box2 = document.getElementById("box2");

        const startX = box1.offsetLeft + box1.offsetWidth / 2;
        const startY = box1.offsetTop + box1.offsetHeight;
        const endX = box2.offsetLeft + box2.offsetWidth / 2;
        const endY = box2.offsetTop;

        for (let i = 0; i <= numSegments; i++) {
          const t = i / numSegments;
          const x = startX + (endX - startX) * t;
          const y = startY + (endY - startY) * t;
          particles.push(new Particle(x, y, i === 0 || i === numSegments));
        }
      }

      // Constraint solver
      function solveConstraints() {
        // Distance constraints between adjacent particles
        for (let iteration = 0; iteration < 5; iteration++) {
          for (let i = 0; i < particles.length - 1; i++) {
            const p1 = particles[i];
            const p2 = particles[i + 1];

            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const diff = (restLength - dist) / dist;

            const offsetX = dx * diff * 0.5 * stiffness * 10;
            const offsetY = dy * diff * 0.5 * stiffness * 10;

            if (!p1.pinned) {
              p1.x -= offsetX;
              p1.y -= offsetY;
            }
            if (!p2.pinned) {
              p2.x += offsetX;
              p2.y += offsetY;
            }
          }
        }
      }

      // Update pinned particle positions based on box positions
      function updatePinnedParticles() {
        const box1 = document.getElementById("box1");
        const box2 = document.getElementById("box2");

        particles[0].x = box1.offsetLeft + box1.offsetWidth / 2;
        particles[0].y = box1.offsetTop + box1.offsetHeight;
        particles[0].oldX = particles[0].x;
        particles[0].oldY = particles[0].y;

        particles[particles.length - 1].x =
          box2.offsetLeft + box2.offsetWidth / 2;
        particles[particles.length - 1].y = box2.offsetTop;
        particles[particles.length - 1].oldX =
          particles[particles.length - 1].x;
        particles[particles.length - 1].oldY =
          particles[particles.length - 1].y;
      }

      // Draw the coiled wire
      function drawWire() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (particles.length < 2) return;

        // Calculate total wire length for coil frequency
        let totalLength = 0;
        for (let i = 0; i < particles.length - 1; i++) {
          const dx = particles[i + 1].x - particles[i].x;
          const dy = particles[i + 1].y - particles[i].y;
          totalLength += Math.sqrt(dx * dx + dy * dy);
        }

        // Coil parameters
        const coilRadius = 8;
        const coilFrequency = totalLength / (15 / coilTightness);

        // Draw shadow first
        ctx.save();
        ctx.translate(4, 6);
        drawCoil(coilRadius, coilFrequency, "rgba(0, 0, 0, 0.3)", 6);
        ctx.restore();

        // Draw main coil with gradient effect
        drawCoil(coilRadius, coilFrequency, null, 5, true);
      }

      function drawCoil(
        radius,
        frequency,
        color,
        lineWidth,
        useGradient = false,
      ) {
        const points = [];
        const coilPoints = 500;

        for (let i = 0; i <= coilPoints; i++) {
          const t = i / coilPoints;

          // Find position along the particle chain
          const segmentFloat = t * (particles.length - 1);
          const segmentIndex = Math.floor(segmentFloat);
          const segmentT = segmentFloat - segmentIndex;

          const p1 = particles[Math.min(segmentIndex, particles.length - 1)];
          const p2 =
            particles[Math.min(segmentIndex + 1, particles.length - 1)];

          // Interpolate position
          const baseX = p1.x + (p2.x - p1.x) * segmentT;
          const baseY = p1.y + (p2.y - p1.y) * segmentT;

          // Calculate tangent direction
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;

          // Perpendicular vector (for coil offset)
          const perpX = -dy / len;
          const perpY = dx / len;

          // Coil offset with sine wave
          const coilPhase = t * frequency * Math.PI * 2;
          const coilOffset = Math.sin(coilPhase) * radius;

          // Z-depth for 3D effect (cosine gives us front/back)
          const zDepth = Math.cos(coilPhase);

          points.push({
            x: baseX + perpX * coilOffset,
            y: baseY + perpY * coilOffset,
            z: zDepth,
          });
        }

        // Sort points by depth and draw back-to-front for 3D effect
        if (useGradient) {
          // Draw back parts first (z < 0)
          ctx.beginPath();
          ctx.strokeStyle = "#1a1a1a";
          ctx.lineWidth = lineWidth + 2;
          ctx.lineCap = "round";

          let drawing = false;
          for (let i = 0; i < points.length; i++) {
            if (points[i].z < 0) {
              if (!drawing) {
                ctx.moveTo(points[i].x, points[i].y);
                drawing = true;
              } else {
                ctx.lineTo(points[i].x, points[i].y);
              }
            } else {
              if (drawing) {
                ctx.stroke();
                ctx.beginPath();
                drawing = false;
              }
            }
          }
          ctx.stroke();

          // Draw front parts (z >= 0) with highlight
          ctx.beginPath();
          ctx.strokeStyle = "#3a3a3a";
          ctx.lineWidth = lineWidth + 2;

          drawing = false;
          for (let i = 0; i < points.length; i++) {
            if (points[i].z >= 0) {
              if (!drawing) {
                ctx.moveTo(points[i].x, points[i].y);
                drawing = true;
              } else {
                ctx.lineTo(points[i].x, points[i].y);
              }
            } else {
              if (drawing) {
                ctx.stroke();
                ctx.beginPath();
                drawing = false;
              }
            }
          }
          ctx.stroke();

          // Draw highlight on front
          ctx.beginPath();
          ctx.strokeStyle = "#5a5a5a";
          ctx.lineWidth = lineWidth - 1;

          drawing = false;
          for (let i = 0; i < points.length; i++) {
            if (points[i].z > 0.5) {
              if (!drawing) {
                ctx.moveTo(points[i].x, points[i].y);
                drawing = true;
              } else {
                ctx.lineTo(points[i].x, points[i].y);
              }
            } else {
              if (drawing) {
                ctx.stroke();
                ctx.beginPath();
                drawing = false;
              }
            }
          }
          ctx.stroke();
        } else {
          // Simple solid color draw
          ctx.beginPath();
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = "round";

          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }
      }

      // Animation loop
      function animate() {
        updatePinnedParticles();

        for (const particle of particles) {
          particle.update();
        }

        solveConstraints();
        drawWire();

        requestAnimationFrame(animate);
      }

      // Dragging functionality
      function makeDraggable(element) {
        let isDragging = false;
        let offsetX, offsetY;

        element.addEventListener("mousedown", (e) => {
          isDragging = true;
          offsetX = e.clientX - element.offsetLeft;
          offsetY = e.clientY - element.offsetTop;
          element.style.cursor = "grabbing";
        });

        element.addEventListener("touchstart", (e) => {
          isDragging = true;
          const touch = e.touches[0];
          offsetX = touch.clientX - element.offsetLeft;
          offsetY = touch.clientY - element.offsetTop;
        });

        document.addEventListener("mousemove", (e) => {
          if (!isDragging) return;

          const x = Math.max(
            0,
            Math.min(
              window.innerWidth - element.offsetWidth,
              e.clientX - offsetX,
            ),
          );
          const y = Math.max(
            0,
            Math.min(
              window.innerHeight - element.offsetHeight,
              e.clientY - offsetY,
            ),
          );

          element.style.left = x + "px";
          element.style.top = y + "px";
        });

        document.addEventListener("touchmove", (e) => {
          if (!isDragging) return;

          const touch = e.touches[0];
          const x = Math.max(
            0,
            Math.min(
              window.innerWidth - element.offsetWidth,
              touch.clientX - offsetX,
            ),
          );
          const y = Math.max(
            0,
            Math.min(
              window.innerHeight - element.offsetHeight,
              touch.clientY - offsetY,
            ),
          );

          element.style.left = x + "px";
          element.style.top = y + "px";
        });

        document.addEventListener("mouseup", () => {
          isDragging = false;
          element.style.cursor = "grab";
        });

        document.addEventListener("touchend", () => {
          isDragging = false;
        });
      }

      // Control listeners
      document.getElementById("stiffness").addEventListener("input", (e) => {
        stiffness = parseFloat(e.target.value);
      });

      document.getElementById("damping").addEventListener("input", (e) => {
        damping = parseFloat(e.target.value);
      });

      document.getElementById("gravity").addEventListener("input", (e) => {
        gravity = parseFloat(e.target.value);
      });

      document
        .getElementById("coilTightness")
        .addEventListener("input", (e) => {
          coilTightness = parseFloat(e.target.value);
        });

      document.getElementById("wireLength").addEventListener("input", (e) => {
        numSegments = parseInt(e.target.value);
        initParticles();
      });

      // Initialize
      function init() {
        const box1 = document.getElementById("box1");
        const box2 = document.getElementById("box2");

        // Position boxes
        box1.style.left = window.innerWidth / 2 - 200 + "px";
        box1.style.top = "150px";

        box2.style.left = window.innerWidth / 2 + 80 + "px";
        box2.style.top = "450px";

        makeDraggable(box1);
        makeDraggable(box2);

        initParticles();
        animate();
      }

      init();

      // Reinitialize on window resize
      window.addEventListener("resize", () => {
        resizeCanvas();
      });
    </script>
  </body>
</html>
